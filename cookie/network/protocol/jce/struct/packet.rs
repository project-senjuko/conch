////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2022-2023 qianjunakasumi <i@qianjunakasumi.ren>               /
//                     qianjunakasumi <qianjunakasumi@outlook.com>             /
//                     https://github.com/qianjunakasumi                       /
//                                                                             /
//     This Source Code Form is subject to the terms of the Mozilla Public     /
//     License, v. 2.0. If a copy of the MPL was not distributed with this     /
//     file, You can obtain one at http://mozilla.org/MPL/2.0/.                /
////////////////////////////////////////////////////////////////////////////////

// This file is automatically @generated by JceGenerator.
// It is not intended for manual editing.

use bytes::{Bytes, BytesMut};
use tracing::{instrument, trace};

use jce::{JceReader, JceWriter};
use jce::field::{JBool, JByte, JceFieldErr, JceKindReader, JceKindWriter, JceStructReader, JceStructWriter, JDouble, JFloat, JInt, JList, JLong, JMap, JShort, JSList, JString};

////////////////////////////////////////////////////////////////////////////////

#[derive(Debug, Default)]
pub struct HttpServerListReq {
    pub uin: JLong,
    pub timeout: JLong,
    pub c: JByte,
    pub imsi: JString,
    pub is_wifi_conn: JInt,
    pub app_id: JLong,
    pub imei: JString,
    pub h: Option<JLong>,
    pub i: Option<JLong>,
    pub j: Option<JLong>,
    pub k: Option<JByte>,
    pub l: Option<JByte>,
    pub m: Option<JLong>,
    pub n: Option<JBool>,
}

impl JceStructWriter for HttpServerListReq {
    #[instrument(fields(str = "HTTP 服务器列表请求结构体"), skip(self, b))]
    fn s_to_bytes(&self, b: &mut BytesMut) {
        let mut w = JceWriter::new(b, 1);
        w.put(&self.uin);
        w.put(&self.timeout);
        w.put(&self.c);
        w.put(&self.imsi);
        w.put(&self.is_wifi_conn);
        w.put(&self.app_id);
        w.put(&self.imei);
        if self.h.is_some() { w.put(&self.h.unwrap()) }
        if self.i.is_some() { w.put(&self.i.unwrap()) }
        if self.j.is_some() { w.put(&self.j.unwrap()) }
        if self.k.is_some() { w.put(&self.k.unwrap()) }
        if self.l.is_some() { w.put(&self.l.unwrap()) }
        if self.m.is_some() { w.put(&self.m.unwrap()) }
        if self.n.is_some() { w.put(&self.n.unwrap()) }
        trace!(dsc = "编码完成");
    }
}

////////////////////////////////////////////////////////////////////////////////

#[derive(Debug, Default)]
pub struct HttpServerListRes {
    pub a: JInt,
    pub socket_mobile_ipv4: JList<HttpServerListResServer>,
    pub socket_wifi_ipv4: JList<HttpServerListResServer>,
    pub d: JInt,
    pub e: JInt,
    pub f: Option<JByte>,
    pub g: Option<JByte>,
    pub h: Option<JInt>,
    pub i: Option<JInt>,
    pub j: Option<JLong>,
    pub k: Option<JInt>,
    pub http_mobile_ipv4: Option<JList<HttpServerListResServer>>,
    pub http_wifi_ipv4: Option<JList<HttpServerListResServer>>,
    pub speedtest_info: Option<JSList>,
    pub socket_ipv6: Option<JList<HttpServerListResServer>>,
    pub http_ipv6: Option<JList<HttpServerListResServer>>,
    pub quic_ipv6: Option<JList<HttpServerListResServer>>,
    pub net_type: Option<JByte>,
    pub he_threshold: Option<JInt>,
    pub policy_id: Option<JString>,
    pub u: Option<JByte>,
}

impl JceStructReader for HttpServerListRes {
    #[instrument(fields(str = "HTTP 服务器列表响应结构体"), skip(self, b))]
    fn s_from_bytes(&mut self, b: &mut Bytes) -> Result<(), JceFieldErr> {
        let mut r = JceReader::with_tag(b, 1);
        self.a = r.get()?;
        self.socket_mobile_ipv4 = r.get()?;
        self.socket_wifi_ipv4 = r.get()?;
        self.d = r.get()?;
        self.e = r.get()?;
        self.f = r.get_optional()?;
        self.g = r.get_optional()?;
        self.h = r.get_optional()?;
        self.i = r.get_optional()?;
        self.j = r.get_optional()?;
        self.k = r.get_optional()?;
        self.http_mobile_ipv4 = r.get_optional()?;
        self.http_wifi_ipv4 = r.get_optional()?;
        self.speedtest_info = r.get_optional()?;
        self.socket_ipv6 = r.get_optional()?;
        self.http_ipv6 = r.get_optional()?;
        self.quic_ipv6 = r.get_optional()?;
        self.net_type = r.get_optional()?;
        self.he_threshold = r.get_optional()?;
        self.policy_id = r.get_optional()?;
        self.u = r.get_optional()?;
        trace!(dsc = "解码完成");
        Ok(())
    }
}

////////////////////////////////////////////////////////////////////////////////

#[derive(Debug, Default)]
pub struct HttpServerListResServer {
    pub ip: JString,
    pub port: JInt,
    pub c: JByte,
    pub d: JByte,
    pub e: Option<JByte>,
    pub f: Option<JInt>,
    pub g: Option<JByte>,
    pub region: Option<JString>,
    pub oper: Option<JString>,
    pub ability: Option<JLong>,
}

impl JceStructReader for HttpServerListResServer {
    #[instrument(fields(str = "HTTP 服务器列表响应服务器结构体"), skip(self, b))]
    fn s_from_bytes(&mut self, b: &mut Bytes) -> Result<(), JceFieldErr> {
        let mut r = JceReader::with_tag(b, 1);
        self.ip = r.get()?;
        self.port = r.get()?;
        self.c = r.get()?;
        self.d = r.get()?;
        self.e = r.get_optional()?;
        self.f = r.get_optional()?;
        self.g = r.get_optional()?;
        self.region = r.get_optional()?;
        self.oper = r.get_optional()?;
        self.ability = r.get_optional()?;
        Ok(())
    }
}

////////////////////////////////////////////////////////////////////////////////

#[derive(Debug, Default)]
pub struct RequestPacket {
    pub version: JShort,
    pub packet_type: JByte,
    pub message_type: JInt,
    pub request_id: JInt,
    pub servant_name: JString,
    pub func_name: JString,
    pub buffer: JSList,
    pub timeout: JInt,
    pub context: JMap<JString, JString>,
    pub status: JMap<JString, JString>,
}

impl JceStructWriter for RequestPacket {
    #[instrument(fields(str = "Jce 请求数据包"), skip(self, b))]
    fn s_to_bytes(&self, b: &mut BytesMut) {
        let mut w = JceWriter::new(b, 1);
        w.put(&self.version);
        w.put(&self.packet_type);
        w.put(&self.message_type);
        w.put(&self.request_id);
        w.put(&self.servant_name);
        w.put(&self.func_name);
        w.put(&self.buffer);
        w.put(&self.timeout);
        w.put(&self.context);
        w.put(&self.status);
        trace!(dsc = "编码完成");
    }
}

impl JceStructReader for RequestPacket {
    #[instrument(fields(str = "Jce 请求数据包"), skip(self, b))]
    fn s_from_bytes(&mut self, b: &mut Bytes) -> Result<(), JceFieldErr> {
        let mut r = JceReader::with_tag(b, 1);
        self.version = r.get()?;
        self.packet_type = r.get()?;
        self.message_type = r.get()?;
        self.request_id = r.get()?;
        self.servant_name = r.get()?;
        self.func_name = r.get()?;
        self.buffer = r.get()?;
        self.timeout = r.get()?;
        self.context = r.get()?;
        self.status = r.get()?;
        trace!(dsc = "解码完成");
        Ok(())
    }
}
