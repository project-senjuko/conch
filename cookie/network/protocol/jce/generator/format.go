////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2022 qianjunakasumi <i@qianjunakasumi.ren>                    /
//                     qianjunakasumi <qianjunakasumi@outlook.com>             /
//                     https://github.com/qianjunakasumi                       /
//                                                                             /
//     This Source Code Form is subject to the terms of the Mozilla Public     /
//     License, v. 2.0. If a copy of the MPL was not distributed with this     /
//     file, You can obtain one at http://mozilla.org/MPL/2.0/.                /
////////////////////////////////////////////////////////////////////////////////

package main

import (
	"strconv"
	"strings"
)

const HEAD = `// This file is automatically @generated by JceGenerator.
// It is not intended for manual editing.

use bytes::{Bytes, BytesMut};
use tracing::{instrument, trace};

use jce::{JceReader, JceWriter};
use jce::field::{JBool, JByte, JceFieldErr, JceKindReader, JceKindWriter, JceStructReader, JceStructWriter, JDouble, JFloat, JInt, JList, JLong, JMap, JShort, JSList, JString};
`
const SEP = `);
`

func format(j *JceSpec) (b strings.Builder) {
	t := "1"
	if st := j.Spec.StartTag; st != nil {
		t = strconv.FormatUint(uint64(*st), 10)
	}

	b.WriteString(formatStruct(j))
	b.WriteString(formatImplToBytes(j, t))
	b.WriteString(formatImplFromBytes(j, t))
	return
}

func formatStruct(j *JceSpec) string {
	var b strings.Builder
	b.WriteString(`
#[derive(Debug, Default)]
pub struct `)
	b.WriteString(j.Metadata.Name)
	b.WriteString(` {
`)
	for i, v := range j.Spec.Fields {
		b.WriteString("    pub ")
		b.WriteString(v.Name)
		b.WriteString(": ")
		if !v.Option {
			b.WriteString(v.Type)
		} else {
			b.WriteString("Option<")
			b.WriteString(v.Type)
			b.WriteString(">")
		}

		b.WriteString(",")
		if i != len(j.Spec.Fields) {
			b.WriteString(`
`)
		}
	}
	b.WriteString(`}
`)

	return b.String()
}

func formatInstrument(j *JceSpec) string {
	var b strings.Builder
	b.WriteString(`
    #[instrument(fields(str = "`)
	b.WriteString(j.Metadata.Description)
	b.WriteString(`"), skip(self, b))]
`)

	return b.String()
}

func formatImplToBytes(j *JceSpec, t string) string {
	if !strings.Contains(j.Spec.Product, "w") {
		return ""
	}

	var b strings.Builder
	b.WriteString(`
impl JceStructWriter for `)
	b.WriteString(j.Metadata.Name)
	b.WriteString(` {`)
	b.WriteString(formatInstrument(j))
	b.WriteString(`    fn s_to_bytes(&self, b: &mut BytesMut) {
        let mut w = JceWriter::new(b, `)
	b.WriteString(t)
	b.WriteString(SEP)
	for i, v := range j.Spec.Fields {
		if v.Tag != nil && *v.Tag != uint8(i)+*j.Spec.StartTag {
			b.WriteString("        w.set_tag(")
			b.WriteString(strconv.FormatUint(uint64(*v.Tag), 10))
			b.WriteString(`);
`)
		}

		if !v.Option {
			b.WriteString("        w.put(&self.")
			b.WriteString(v.Name)
			b.WriteString(");")
		} else {
			b.WriteString(`        if self.`)
			b.WriteString(v.Name)
			b.WriteString(`.is_some() { w.put(&self.`)
			b.WriteString(v.Name)
			b.WriteString(`.unwrap()) }`)
		}
		b.WriteString(`
`)
	}
	if !j.Metadata.SkipPrint {
		b.WriteString(`        trace!(dsc = "编码完成");
`)
	}
	b.WriteString(`    }
}
`)

	return b.String()
}

func formatImplFromBytes(j *JceSpec, t string) string {
	if !strings.Contains(j.Spec.Product, "r") {
		return ""
	}

	var b strings.Builder
	b.WriteString(`
impl JceStructReader for `)
	b.WriteString(j.Metadata.Name)
	b.WriteString(` {`)
	b.WriteString(formatInstrument(j))
	b.WriteString(`    fn s_from_bytes(&mut self, b: &mut Bytes) -> Result<(), JceFieldErr> {
        let mut r = JceReader::with_tag(b, `)
	b.WriteString(t)
	b.WriteString(SEP)
	for i, v := range j.Spec.Fields {
		if v.Tag != nil && *v.Tag != uint8(i)+*j.Spec.StartTag {
			b.WriteString("        r.set_tag(")
			b.WriteString(strconv.FormatUint(uint64(*v.Tag), 10))
			b.WriteString(`);
`)
		}

		b.WriteString("        self.")
		b.WriteString(v.Name)
		b.WriteString(" = ")
		if !v.Option {
			b.WriteString("r.get()?;")
		} else {
			b.WriteString("r.get_optional()?;")
		}

		if i != len(j.Spec.Fields) {
			b.WriteString(`
`)
		}
	}
	if !j.Metadata.SkipPrint {
		b.WriteString(`        trace!(dsc = "解码完成");
`)
	}
	b.WriteString(`        Ok(())
    }
}
`)

	return b.String()
}
